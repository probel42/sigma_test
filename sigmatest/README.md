btw эта задача по сути является реализацией упрощенной версии известного многим акинатора.

# Допущения
При решении возник ряд вопросов. В реальных задачах эти вопросы направлялись бы аналитику,
но т.к. задача тестовая и небольшая, то вопросы превратились в допущения, поэтому допустим что:
1. Когда пользователям предлагают ввести различия между животными, пользователи всегда будут вводить краткий критерий
   типа "умеет плавать", "синего цвета", но не "рыба умеет плавать, а птица летает".
2. Вводимые критерии различия не зависят от пользователя (объективны).
3. Вводимые критерии различия не зависят от времени (точнее так: их истинность не изменится в будущем).
4. Предположим, что базу знаний необходимо сохранить при перезапуске приложения (для этого нужно подобрать некоторую бд).
5. Предположим, что животных и вопросов в перспективе будет много и приложение нужно оптимизировать по скорости
    - скорости подбора очередного вопроса
    - скорости добавления животного
    - скорости добавления вопроса
6. Предположим, что кол-во вопросов желательно свести к разумному минимуму.
7. Все вопросы в приложении являются логически изолированными, т.е. приложение никак не будет выявлять логическую
   взаимосвязь между вопросами и записывать эту связь в базу знаний.
   Например: "есть уши" и "может слышать" - разные вопросы. Из первого не следует второе и из второго не следует первое.

# Подбор структуры хранения
Структур хранения в памяти может быть несколько. Например, матрица со значениями да / нет / не знаю.
Такая матрица позволила бы оптимизировать подбор вопросов, ставя вперёд вопросы разбивающие всех оставшихся
в текущей итерации животных примерно пополам. Однако подбор очередного вопроса в таком случае занял бы M*N времени.

Поэтому прежде всего на ум приходит дерево выбора (т.е. бинарное дерево с предикатами в узлах).
Основными проблемами такого подхода является несбалансированность дерева,
а также возможный повтор вопросов в узлах, которые не являются предками/потомками друг друга (из разных веток).

# Реализация
Т.к. задача в целом не очень большая, то и в реализации не используется практические ничего
(только javafx для вывода и ломбок). Без спринга.